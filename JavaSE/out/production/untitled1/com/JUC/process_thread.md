# Java.Util.Concurrent

底层调度时机不由代码编写顺序或jvm决定、由CPU决定

## 进程

  动态的程序就是进程

  动态体现在：

  1. 占用内存、CPU、IO等各种资源
  2. 有创建、运行、销毁等生命周期
  3. 可以交互

## 线程

将进程<==>所有系统资源

缩放到

进程下属线程<==>该进程拥有的系统资源

守护线程：当所有用户线程结束，自动结束。比如GC, word意外关闭后.sav恢复(线程一直在守护)

## 并发VS并行

并发：单核，CPU数<任务数，一定存在并发，交替执行，快，看着像并行，时间片轮转

并行：多核，CPU数>任务数，不一定并行，同时执行，更快

## 释放锁VS不释放锁 的操作

![avatar](https://img-blog.csdnimg.cn/66e3f4e85242456e846ec2a24b5be82e.png)

释放锁：

1. synchronized执行完
2. synchronized执行中遇到break,return,Error,Exception
3. 调用线程对象wait()

不释放锁：

1. sleep()、yield()占着茅坑不拉屎

## 同步监视器

一个锁资源，对于被synchronized修饰的同步方法/代码块而言，无论有多少线程调用此方法/代码块，这种锁资源都在内存中只有一个实体，保证只有一个线程能获取到该资源。

在非静态方法中，同步监视器默认为this(当前对象)；静态方法，同步监视器默认为类.Class(只加载一次)

❗如果静态方法默认的this锁不住临界资源，则改为锁共享的临界资源本身：

比如账户类Account是临界资源，而用另一个提款Drawing类实现Runnable接口，那么如果在Drawing类里用synchronized锁方法，默认锁this(即Drawing类的对象)，临界资源Account并没有被锁住。

改为锁代码块，同步监视器为account对象。

| synchronized | static方法间 | 普通方法间 | static与普通方法间 |
| :----------: | :----------: | :--------: | :----------------: |
|  同类同对象  |     竞争     |    竞争    |       不竞争       |
| 同类不同对象 |     竞争     |   不竞争   |       不竞争       |

## 编写多线程代码的思路

高内聚、低耦合 + [线程、 操作、 资源类]

## JVM所处位置

硬件->OS->JRE(JVM)->Java程序
