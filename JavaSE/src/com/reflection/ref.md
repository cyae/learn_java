
# Class

Class对象也继承自Object，但：

1. 只有一个有参的私有构造器，使用classLoader作为参数。即Class对象只能由jvm创建，无法手动new
2. 为了节省内存空间，同种类的类加载只有一次，所以同种类的Class对象也只有一份
3. 每个类对象都保存堆中Class对象的地址，通过.getClass()返回
4. Class对象留存了该类的完整信息，包括属性、方法、构造器、接口...
5. 在堆中生成Class对象后，在方法区同步生成二进制的 类.class 文件，方便jvm使用

# 静态加载VS动态加载

1. 静态加载：在编译阶段导包决定需要用到的类，如果没导包就报错。依赖性强。
2. 动态加载：在运行阶段通过反射读入需要用到的类，无需导包。降低依赖性

# 类加载时机

1. new对象（静）
2. 子类加载，父类也加载（静）
3. 调用类的静态成员（静）
4. 反射动态加载

# 类加载过程

源码====[javac编译]===>字节码.class====[java运行]====>类加载3阶段：
1.加载: 类加载器将字节码(.class文件/.jar/internet)二进制读入内存，加载到方法区，并在堆生成Class对象
2.连接:
    2.1.验证(格式0xcafebabe开头?、字节码、符号引用、元数据验证，保证不会危害jvm安全,-Xverify:none可以关闭此阶段)
    2.2.准备(给静态变量分配方法区内存并默认初始化, 给常量static final显示初始化)
    2.3.解析(JVM将常量池中的符号引用(Class clazz = 类.class)替换为直接地址引用(0xE332))
3.初始化:(使用clinit方法，按顺序收集 静态代码块/变量 显式初始化, e.g. static int a = 100；
如果有多个线程初始化一个类，clinit方法会加锁执行，即保证只有一个线程执行clinit方法，其他都阻塞：
synchronized (getClassLoadingLock(className)) {...}
这保证了类在内存中只有一份Class模板对象，即所谓类只加载一次
)
